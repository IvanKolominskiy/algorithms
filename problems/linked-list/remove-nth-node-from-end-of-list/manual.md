### Решение

class Solution:
def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
dummy_node = ListNode(next=head)

            fast = dummy_node
            slow = dummy_node

            for _ in range(n + 1):
                fast = fast.next

            while fast is not None:
                fast = fast.next
                slow = slow.next

            slow.next = slow.next.next

            return dummy_node.next

### Оценка по времени: O(n), где n - размер связного списка

Объяснения: делаем 2 прохода по связанному списку, первый - чтобы сдвинуть fast указатель на n + 1 (Худший случай O(n) операций), второй - чтобы сдвинуть указатель до nil ноды (Худший случай O(n) операций). В итоге получаем сложность O(n)

### Оценка по памяти: O(1)

### Описание решения

Вся суть решения заключается в том, чтобы дойти до ноды, которая является предыдущей для искомой. Дойдя до такой ноды мы можем легко удалить следующую. Но у head ноды нет предыдущей, для этого мы используем dummy node, которую мы присоединияем к head. Для того чтобы дойти до предыдущей ноды, мы используем fast и slow указатели. Для начала нам нужно сдвинуть fast указатель на n+1. Далее мы сдвигаем оба наших указателя до того момента пока fast не дойдет до nil ноды. Когда это произойдет, slow указатель будет указывать как раз на необоходимую нам предыдущую ноду.
